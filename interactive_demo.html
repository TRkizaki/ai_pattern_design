<!DOCTYPE html>



<html lang="en">

    <head>

        <meta charset="UTF-8">

        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <title>Pattern Recognition: Interactive Demo</title>

        <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.26.0/plotly.min.js"></script>

        <style>

* {

    margin: 0;

    padding: 0;

    box-sizing: border-box;

}



```

body {

    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;

    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);

    min-height: 100vh;

    color: #333;

}



.container {

    max-width: 1400px;

    margin: 0 auto;

    padding: 20px;

}



.header {

    text-align: center;

    color: white;

    margin-bottom: 30px;

}



.header h1 {

    font-size: 2.5em;

    margin-bottom: 10px;

    text-shadow: 2px 2px 4px rgba(0,0,0,0.3);

}



.header p {

    font-size: 1.2em;

    opacity: 0.9;

}



.demo-section {

    background: white;

    border-radius: 15px;

    padding: 25px;

    margin-bottom: 30px;

    box-shadow: 0 10px 30px rgba(0,0,0,0.1);

    transition: transform 0.3s ease;

}



.demo-section:hover {

    transform: translateY(-5px);

}



.demo-title {

    font-size: 1.8em;

    color: #4a5568;

    margin-bottom: 15px;

    border-bottom: 3px solid #667eea;

    padding-bottom: 10px;

}



.controls {

    display: flex;

    flex-wrap: wrap;

    gap: 15px;

    margin-bottom: 20px;

    align-items: center;

}



.control-group {

    display: flex;

    align-items: center;

    gap: 10px;

}



.control-group label {

    font-weight: bold;

    color: #4a5568;

}



.btn {

    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);

    color: white;

    border: none;

    padding: 10px 20px;

    border-radius: 25px;

    cursor: pointer;

    font-weight: bold;

    transition: all 0.3s ease;

}



.btn:hover {

    transform: translateY(-2px);

    box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);

}



.btn:active {

    transform: translateY(0);

}



.slider {

    width: 150px;

    height: 8px;

    border-radius: 5px;

    background: #ddd;

    outline: none;

    -webkit-appearance: none;

}



.slider::-webkit-slider-thumb {

    -webkit-appearance: none;

    appearance: none;

    width: 20px;

    height: 20px;

    border-radius: 50%;

    background: #667eea;

    cursor: pointer;

}



.plot-container {

    height: 500px;

    border: 2px solid #e2e8f0;

    border-radius: 10px;

    background: #f8fafc;

}



.algorithm-info {

    background: #f7fafc;

    border-left: 4px solid #667eea;

    padding: 15px;

    margin: 15px 0;

    border-radius: 0 10px 10px 0;

}



.stats {

    display: grid;

    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));

    gap: 15px;

    margin-top: 20px;

}



.stat-card {

    background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);

    color: white;

    padding: 15px;

    border-radius: 10px;

    text-align: center;

}



.stat-value {

    font-size: 2em;

    font-weight: bold;

}



.stat-label {

    font-size: 0.9em;

    opacity: 0.9;

}



.tab-container {

    display: flex;

    margin-bottom: 20px;

}



.tab {

    flex: 1;

    padding: 12px 20px;

    background: #e2e8f0;

    border: none;

    cursor: pointer;

    font-weight: bold;

    transition: all 0.3s ease;

}



.tab:first-child {

    border-radius: 10px 0 0 10px;

}



.tab:last-child {

    border-radius: 0 10px 10px 0;

}



.tab.active {

    background: #667eea;

    color: white;

}



.tab-content {

    display: none;

}



.tab-content.active {

    display: block;

}



@media (max-width: 768px) {

    .controls {

        flex-direction: column;

        align-items: stretch;

    }



    .control-group {

        justify-content: center;

    }



    .header h1 {

        font-size: 2em;

    }

}

        </style>

        ```



    </head>

    <body>

        <div class="container">

            <div class="header">

                <h1>ðŸ¤– Pattern Recognition Interactive Demo</h1>

                <p>Master's Course Presentation - Decision Methods & Clustering</p>

            </div>



            ```

            <!-- Classification Demo -->

            <div class="demo-section">

                <h2 class="demo-title">ðŸŽ¯ Classification Algorithms Demo</h2>



                <div class="tab-container">

                    <button class="tab active" onclick="showTab('nn-tab')">Nearest Neighbor</button>

                    <button class="tab" onclick="showTab('bayes-tab')">Bayesian Classification</button>

                    <button class="tab" onclick="showTab('comparison-tab')">Algorithm Comparison</button>

                </div>



                <div id="nn-tab" class="tab-content active">

                    <div class="algorithm-info">

                        <strong>Nearest Neighbor Algorithm:</strong> Classifies unknown samples by finding the closest training sample in feature space. Simple but effective!

                    </div>



                    <div class="controls">

                        <div class="control-group">

                            <label>K Value:</label>

                            <input type="range" id="kValue" class="slider" min="1" max="15" value="1" oninput="updateKNN()">

                            <span id="kValueDisplay">1</span>

                        </div>

                        <button class="btn" onclick="generateClassificationData()">Generate New Data</button>

                        <button class="btn" onclick="addTestPoint()">Add Test Point</button>

                        <button class="btn" onclick="clearTestPoints()">Clear Test Points</button>

                    </div>



                    <div id="nnPlot" class="plot-container"></div>



                    <div class="stats">

                        <div class="stat-card">

                            <div class="stat-value" id="nnAccuracy">0%</div>

                            <div class="stat-label">Accuracy</div>

                        </div>

                        <div class="stat-card">

                            <div class="stat-value" id="nnTrainingSize">0</div>

                            <div class="stat-label">Training Samples</div>

                        </div>

                        <div class="stat-card">

                            <div class="stat-value" id="nnTestSize">0</div>

                            <div class="stat-label">Test Points</div>

                        </div>

                    </div>

                </div>



                <div id="bayes-tab" class="tab-content">

                    <div class="algorithm-info">

                        <strong>Bayesian Classification:</strong> Uses probability theory to make optimal decisions. Considers prior probabilities and likelihood functions.

                    </div>



                    <div class="controls">

                        <div class="control-group">

                            <label>Prior Weight:</label>

                            <input type="range" id="priorWeight" class="slider" min="0" max="100" value="50" oninput="updateBayesian()">

                            <span id="priorWeightDisplay">0.5</span>

                        </div>

                        <button class="btn" onclick="generateBayesianData()">Generate New Data</button>

                        <button class="btn" onclick="togglePriorVisualization()">Toggle Prior Visualization</button>

                    </div>



                    <div id="bayesPlot" class="plot-container"></div>



                    <div class="stats">

                        <div class="stat-card">

                            <div class="stat-value" id="bayesAccuracy">0%</div>

                            <div class="stat-label">Accuracy</div>

                        </div>

                        <div class="stat-card">

                            <div class="stat-value" id="bayesLogLikelihood">0</div>

                            <div class="stat-label">Log Likelihood</div>

                        </div>

                        <div class="stat-card">

                            <div class="stat-value" id="bayesOptimal">Yes</div>

                            <div class="stat-label">Theoretically Optimal</div>

                        </div>

                    </div>

                </div>



                <div id="comparison-tab" class="tab-content">

                    <div class="algorithm-info">

                        <strong>Algorithm Comparison:</strong> Compare Nearest Neighbor vs Bayesian performance across different scenarios.

                    </div>



                    <div class="controls">

                        <div class="control-group">

                            <label>Noise Level:</label>

                            <input type="range" id="noiseLevel" class="slider" min="0" max="100" value="20" oninput="updateComparison()">

                            <span id="noiseLevelDisplay">20%</span>

                        </div>

                        <div class="control-group">

                            <label>Sample Size:</label>

                            <input type="range" id="sampleSize" class="slider" min="50" max="500" value="200" oninput="updateComparison()">

                            <span id="sampleSizeDisplay">200</span>

                        </div>

                        <button class="btn" onclick="runComparison()">Run Comparison</button>

                    </div>



                    <div id="comparisonPlot" class="plot-container"></div>



                    <div class="stats">

                        <div class="stat-card">

                            <div class="stat-value" id="nnCompAccuracy">0%</div>

                            <div class="stat-label">NN Accuracy</div>

                        </div>

                        <div class="stat-card">

                            <div class="stat-value" id="bayesCompAccuracy">0%</div>

                            <div class="stat-label">Bayes Accuracy</div>

                        </div>

                        <div class="stat-card">

                            <div class="stat-value" id="winner">-</div>

                            <div class="stat-label">Winner</div>

                        </div>

                    </div>

                </div>

            </div>



            <!-- Clustering Demo -->

            <div class="demo-section">

                <h2 class="demo-title">ðŸŽ¨ K-Means Clustering Demo</h2>



                <div class="algorithm-info">

                    <strong>K-Means Algorithm:</strong> Partitions data into K clusters by iteratively updating cluster centers. Watch the centroids move to find optimal positions!

                </div>



                <div class="controls">

                    <div class="control-group">

                        <label>Number of Clusters (K):</label>

                        <input type="range" id="numClusters" class="slider" min="2" max="8" value="3" oninput="updateClusters()">

                        <span id="numClustersDisplay">3</span>

                    </div>

                    <div class="control-group">

                        <label>Animation Speed:</label>

                        <input type="range" id="animSpeed" class="slider" min="100" max="2000" value="500" oninput="updateAnimSpeed()">

                        <span id="animSpeedDisplay">500ms</span>

                    </div>

                    <button class="btn" onclick="generateClusterData()">Generate New Data</button>

                    <button class="btn" onclick="startKMeans()">Start K-Means</button>

                    <button class="btn" onclick="stepKMeans()">Step by Step</button>

                    <button class="btn" onclick="resetKMeans()">Reset</button>

                </div>



                <div id="clusterPlot" class="plot-container"></div>



                <div class="stats">

                    <div class="stat-card">

                        <div class="stat-value" id="iterations">0</div>

                        <div class="stat-label">Iterations</div>

                    </div>

                    <div class="stat-card">

                        <div class="stat-value" id="inertia">0</div>

                        <div class="stat-label">Inertia (Lower = Better)</div>

                    </div>

                    <div class="stat-card">

                        <div class="stat-value" id="converged">No</div>

                        <div class="stat-label">Converged</div>

                    </div>

                    <div class="stat-card">

                        <div class="stat-value" id="silhouette">0</div>

                        <div class="stat-label">Silhouette Score</div>

                    </div>

                </div>

            </div>



            <!-- Feature Dimensionality Demo -->

            <div class="demo-section">

                <h2 class="demo-title">ðŸ“Š Feature Dimensionality Demo</h2>



                <div class="algorithm-info">

                    <strong>Curse of Dimensionality:</strong> Observe how classification performance changes with the number of features. More isn't always better!

                </div>



                <div class="controls">

                    <div class="control-group">

                        <label>Number of Features:</label>

                        <input type="range" id="numFeatures" class="slider" min="1" max="10" value="2" oninput="updateFeatures()">

                        <span id="numFeaturesDisplay">2</span>

                    </div>

                    <div class="control-group">

                        <label>Training Size:</label>

                        <input type="range" id="trainingSize" class="slider" min="20" max="500" value="100" oninput="updateFeatures()">

                        <span id="trainingSizeDisplay">100</span>

                    </div>

                    <button class="btn" onclick="runFeatureExperiment()">Run Experiment</button>

                </div>



                <div id="featurePlot" class="plot-container"></div>



                <div class="stats">

                    <div class="stat-card">

                        <div class="stat-value" id="optimalFeatures">2</div>

                        <div class="stat-label">Optimal Features</div>

                    </div>

                    <div class="stat-card">

                        <div class="stat-value" id="maxAccuracy">0%</div>

                        <div class="stat-label">Max Accuracy</div>

                    </div>

                    <div class="stat-card">

                        <div class="stat-value" id="overfitting">No</div>

                        <div class="stat-label">Overfitting Detected</div>

                    </div>

                </div>

            </div>

        </div>



        <script>

            // Global variables for data and algorithms

            let classificationData = {};

            let clusterData = {};

            let kmeansState = {};

            let currentIteration = 0;

            let animationId = null;

            let testPoints = [];



            // Initialize the demo

            document.addEventListener('DOMContentLoaded', function() {

                generateClassificationData();

                generateClusterData();

                generateBayesianData();

                runFeatureExperiment();

            });



            // Tab functionality

            function showTab(tabId) {

                // Hide all tab contents

                const tabContents = document.querySelectorAll('.tab-content');

                tabContents.forEach(content => content.classList.remove('active'));



                // Remove active class from all tabs

                const tabs = document.querySelectorAll('.tab');

                tabs.forEach(tab => tab.classList.remove('active'));



                // Show selected tab content

                document.getElementById(tabId).classList.add('active');



                // Add active class to clicked tab

                const clickedTab = event.target;

                clickedTab.classList.add('active');

            }



            // Generate random classification data

            function generateClassificationData() {

                const n = 100;

                const data = {

                    class1: { x: [], y: [], label: [] },

                    class2: { x: [], y: [], label: [] }

                };



                // Generate class 1 data (centered around (2, 2))

                for (let i = 0; i < n/2; i++) {

                    data.class1.x.push(2 + (Math.random() - 0.5) * 3);

                    data.class1.y.push(2 + (Math.random() - 0.5) * 3);

                    data.class1.label.push('Class 1');

                }



                // Generate class 2 data (centered around (6, 6))

                for (let i = 0; i < n/2; i++) {

                    data.class2.x.push(6 + (Math.random() - 0.5) * 3);

                    data.class2.y.push(6 + (Math.random() - 0.5) * 3);

                    data.class2.label.push('Class 2');

                }



                classificationData = data;

                updateKNN();

                updateStats();

            }



            // Update K-NN visualization

            function updateKNN() {

                const k = parseInt(document.getElementById('kValue').value);

                document.getElementById('kValueDisplay').textContent = k;



                const traces = [

                    {

                        x: classificationData.class1.x,

                        y: classificationData.class1.y,

                        mode: 'markers',

                        type: 'scatter',

                        name: 'Class 1',

                        marker: { color: 'blue', size: 8 }

                    },

                    {

                        x: classificationData.class2.x,

                        y: classificationData.class2.y,

                        mode: 'markers',

                        type: 'scatter',

                        name: 'Class 2',

                        marker: { color: 'red', size: 8 }

                    }

                ];



                // Add test points if any

                if (testPoints.length > 0) {

                    traces.push({

                        x: testPoints.map(p => p.x),

                        y: testPoints.map(p => p.y),

                        mode: 'markers',

                        type: 'scatter',

                        name: 'Test Points',

                        marker: { color: 'green', size: 12, symbol: 'star' }

                    });

                }



                const layout = {

                    title: `K-Nearest Neighbor (K=${k})`,

                    xaxis: { title: 'Feature 1' },

                    yaxis: { title: 'Feature 2' },

                    showlegend: true,

                    hovermode: 'closest'

                };



                Plotly.newPlot('nnPlot', traces, layout);

            }



            // Add test point on click

            function addTestPoint() {

                const x = Math.random() * 8 + 1;

                const y = Math.random() * 8 + 1;

                testPoints.push({ x: x, y: y });

                updateKNN();

                updateStats();

            }



            // Clear test points

            function clearTestPoints() {

                testPoints = [];

                updateKNN();

                updateStats();

            }



            // Generate Bayesian data

            function generateBayesianData() {

                const n = 200;

                const data = {

                    class1: { x: [], y: [] },

                    class2: { x: [], y: [] }

                };



                // Generate overlapping Gaussian distributions

                for (let i = 0; i < n/2; i++) {

                    // Class 1: mean (3, 3), std 1.5

                    data.class1.x.push(3 + Math.random() * 3 - 1.5);

                    data.class1.y.push(3 + Math.random() * 3 - 1.5);

                }



                for (let i = 0; i < n/2; i++) {

                    // Class 2: mean (5, 5), std 2

                    data.class2.x.push(5 + Math.random() * 4 - 2);

                    data.class2.y.push(5 + Math.random() * 4 - 2);

                }



                updateBayesian();

            }



            // Update Bayesian visualization

            function updateBayesian() {

                const priorWeight = parseFloat(document.getElementById('priorWeight').value) / 100;

                document.getElementById('priorWeightDisplay').textContent = priorWeight.toFixed(1);



                const traces = [

                    {

                        x: classificationData.class1.x,

                        y: classificationData.class1.y,

                        mode: 'markers',

                        type: 'scatter',

                        name: 'Class 1',

                        marker: { color: 'blue', size: 8, opacity: 0.7 }

                    },

                    {

                        x: classificationData.class2.x,

                        y: classificationData.class2.y,

                        mode: 'markers',

                        type: 'scatter',

                        name: 'Class 2',

                        marker: { color: 'red', size: 8, opacity: 0.7 }

                    }

                ];



                // Add decision boundary visualization

                const x_range = [];

                const y_range = [];

                const z_values = [];



                for (let x = 0; x <= 8; x += 0.2) {

                    for (let y = 0; y <= 8; y += 0.2) {

                        x_range.push(x);

                        y_range.push(y);

                        // Simplified Bayesian decision (in practice, would use actual probability calculations)

                        const dist1 = Math.sqrt((x - 2)**2 + (y - 2)**2);

                        const dist2 = Math.sqrt((x - 6)**2 + (y - 6)**2);

                        const posterior = (dist1 < dist2) ? priorWeight : 1 - priorWeight;

                        z_values.push(posterior);

                    }

                }



                traces.push({

                    x: x_range,

                    y: y_range,

                    z: z_values,

                    type: 'contour',

                    colorscale: 'RdYlBu',

                    showscale: false,

                    opacity: 0.3,

                    name: 'Decision Boundary'

                });



                const layout = {

                    title: `Bayesian Classification (Prior Weight: ${priorWeight.toFixed(1)})`,

                    xaxis: { title: 'Feature 1' },

                    yaxis: { title: 'Feature 2' },

                    showlegend: true

                };



                Plotly.newPlot('bayesPlot', traces, layout);

            }



            // Generate cluster data

            function generateClusterData() {

                const n = 150;

                const data = { x: [], y: [] };



                // Generate 3 natural clusters

                const centers = [[2, 2], [6, 3], [4, 7]];



                for (let i = 0; i < n; i++) {

                    const cluster = Math.floor(Math.random() * 3);

                    const center = centers[cluster];

                    data.x.push(center[0] + (Math.random() - 0.5) * 2);

                    data.y.push(center[1] + (Math.random() - 0.5) * 2);

                }



                clusterData = data;

                resetKMeans();

            }



            // Update clusters

            function updateClusters() {

                const k = parseInt(document.getElementById('numClusters').value);

                document.getElementById('numClustersDisplay').textContent = k;

                resetKMeans();

            }



            // Update animation speed

            function updateAnimSpeed() {

                const speed = parseInt(document.getElementById('animSpeed').value);

                document.getElementById('animSpeedDisplay').textContent = speed + 'ms';

            }



            // Reset K-means

            function resetKMeans() {

                const k = parseInt(document.getElementById('numClusters').value);



                // Initialize random centroids

                const centroids = [];

                for (let i = 0; i < k; i++) {

                    centroids.push({

                        x: Math.random() * 8 + 1,

                        y: Math.random() * 8 + 1

                    });

                }



                kmeansState = {

                    centroids: centroids,

                    assignments: new Array(clusterData.x.length).fill(0),

                    iteration: 0,

                    converged: false

                };



                currentIteration = 0;

                updateClusterVisualization();

                updateClusterStats();

            }



            // Start K-means animation

            function startKMeans() {

                if (animationId) {

                    clearInterval(animationId);

                }



                const speed = parseInt(document.getElementById('animSpeed').value);

                animationId = setInterval(() => {

                    if (!kmeansState.converged) {

                        stepKMeans();

                    } else {

                        clearInterval(animationId);

                    }

                }, speed);

            }



            // Single step of K-means

            function stepKMeans() {

                if (kmeansState.converged) return;



                const k = kmeansState.centroids.length;

                const newAssignments = [];



                // Assign each point to nearest centroid

                for (let i = 0; i < clusterData.x.length; i++) {

                    let minDist = Infinity;

                    let bestCluster = 0;



                    for (let j = 0; j < k; j++) {

                        const dist = Math.sqrt(

                            (clusterData.x[i] - kmeansState.centroids[j].x)**2 +

                            (clusterData.y[i] - kmeansState.centroids[j].y)**2

                        );

                        if (dist < minDist) {

                            minDist = dist;

                            bestCluster = j;

                        }

                    }

                    newAssignments.push(bestCluster);

                }



                // Update centroids

                const newCentroids = [];

                for (let j = 0; j < k; j++) {

                    const clusterPoints = { x: [], y: [] };

                    for (let i = 0; i < clusterData.x.length; i++) {

                        if (newAssignments[i] === j) {

                            clusterPoints.x.push(clusterData.x[i]);

                            clusterPoints.y.push(clusterData.y[i]);

                        }

                    }



                    if (clusterPoints.x.length > 0) {

                        const avgX = clusterPoints.x.reduce((a, b) => a + b) / clusterPoints.x.length;

                        const avgY = clusterPoints.y.reduce((a, b) => a + b) / clusterPoints.y.length;

                        newCentroids.push({ x: avgX, y: avgY });

                    } else {

                        newCentroids.push(kmeansState.centroids[j]);

                    }

                }



                // Check convergence

                let converged = true;

                for (let j = 0; j < k; j++) {

                    const dist = Math.sqrt(

                        (newCentroids[j].x - kmeansState.centroids[j].x)**2 +

                        (newCentroids[j].y - kmeansState.centroids[j].y)**2

                    );

                    if (dist > 0.01) {

                        converged = false;

                        break;

                    }

                }



                kmeansState.assignments = newAssignments;

                kmeansState.centroids = newCentroids;

                kmeansState.iteration++;

                kmeansState.converged = converged;



                updateClusterVisualization();

                updateClusterStats();

            }



            // Update cluster visualization

            function updateClusterVisualization() {

                const colors = ['blue', 'red', 'green', 'orange', 'purple', 'brown', 'pink', 'gray'];

                const traces = [];



                // Plot data points colored by cluster assignment

                for (let j = 0; j < kmeansState.centroids.length; j++) {

                    const clusterX = [];

                    const clusterY = [];



                    for (let i = 0; i < clusterData.x.length; i++) {

                        if (kmeansState.assignments[i] === j) {

                            clusterX.push(clusterData.x[i]);

                            clusterY.push(clusterData.y[i]);

                        }

                    }



                    if (clusterX.length > 0) {

                        traces.push({

                            x: clusterX,

                            y: clusterY,

                            mode: 'markers',

                            type: 'scatter',

                            name: `Cluster ${j + 1}`,

                            marker: { color: colors[j], size: 6 }

                        });

                    }

                }



                // Plot centroids

                traces.push({

                    x: kmeansState.centroids.map(c => c.x),

                    y: kmeansState.centroids.map(c => c.y),

                    mode: 'markers',

                    type: 'scatter',

                    name: 'Centroids',

                    marker: {

                        color: 'black',

                        size: 15,

                        symbol: 'cross',

                        line: { color: 'white', width: 2 }

                    }

                });



                const layout = {

                    title: `K-Means Clustering (Iteration: ${kmeansState.iteration})`,

                    xaxis: { title: 'Feature 1' },

                    yaxis: { title: 'Feature 2' },

                    showlegend: true

                };



                Plotly.newPlot('clusterPlot', traces, layout);

            }



            // Update cluster statistics

            function updateClusterStats() {

                document.getElementById('iterations').textContent = kmeansState.iteration;

                document.getElementById('converged').textContent = kmeansState.converged ? 'Yes' : 'No';



                // Calculate inertia (within-cluster sum of squares)

                let inertia = 0;

                for (let i = 0; i < clusterData.x.length; i++) {

                    const cluster = kmeansState.assignments[i];

                    const centroid = kmeansState.centroids[cluster];

                    inertia += (clusterData.x[i] - centroid.x)**2 + (clusterData.y[i] - centroid.y)**2;

                }

                document.getElementById('inertia').textContent = inertia.toFixed(1);



                // Calculate silhouette score (simplified)

                let silhouette = 0;

                if (kmeansState.centroids.length > 1) {

                    for (let i = 0; i < Math.min(50, clusterData.x.length); i++) {

                        const cluster = kmeansState.assignments[i];

                        let a = 0, b = Infinity;



                        // Calculate a: average distance to points in same cluster

                        let sameClusterCount = 0;

                        for (let j = 0; j < clusterData.x.length; j++) {

                            if (i !== j && kmeansState.assignments[j] === cluster) {

                                a += Math.sqrt((clusterData.x[i] - clusterData.x[j])**2 +

                                    (clusterData.y[i] - clusterData.y[j])**2);

                                sameClusterCount++;

                            }

                        }

                        if (sameClusterCount > 0) a /= sameClusterCount;



                        // Calculate b: minimum average distance to points in other clusters

                        for (let k = 0; k < kmeansState.centroids.length; k++) {

                            if (k !== cluster) {

                                let otherClusterDist = 0;

                                let otherClusterCount = 0;

                                for (let j = 0; j < clusterData.x.length; j++) {

                                    if (kmeansState.assignments[j] === k) {

                                        otherClusterDist += Math.sqrt((clusterData.x[i] - clusterData.x[j])**2 +

                                            (clusterData.y[i] - clusterData.y[j])**2);

                                        otherClusterCount++;

                                    }

                                }

                                if (otherClusterCount > 0) {

                                    b = Math.min(b, otherClusterDist / otherClusterCount);

                                }

                            }

                        }



                        if (a < b) {

                            silhouette += (b - a) / b;

                        } else if (a > b) {

                            silhouette += (b - a) / a;

                        }

                    }

                    silhouette /= Math.min(50, clusterData.x.length);

                }

                document.getElementById('silhouette').textContent = silhouette.toFixed(3);

            }



            // Update feature dimensionality

            function updateFeatures() {

                const numFeatures = parseInt(document.getElementById('numFeatures').value);

                const trainingSize = parseInt(document.getElementById('trainingSize').value);

                document.getElementById('numFeaturesDisplay').textContent = numFeatures;

                document.getElementById('trainingSizeDisplay').textContent = trainingSize;

            }



            // Run feature experiment

            function runFeatureExperiment() {

                const maxFeatures = 10;

                const accuracies = [];

                const featureCounts = [];



                for (let features = 1; features <= maxFeatures; features++) {

                    // Simulate accuracy vs feature count

                    const trainingSize = parseInt(document.getElementById('trainingSize').value);

                    const optimalFeatures = Math.max(2, Math.floor(Math.log(trainingSize) / Math.log(10)));



                    let accuracy;

                    if (features <= optimalFeatures) {

                        // Accuracy increases with more features up to optimal point

                        accuracy = 0.6 + 0.3 * (features / optimalFeatures);

                    } else {

                        // Accuracy decreases after optimal point (curse of dimensionality)

                        const penalty = (features - optimalFeatures) / maxFeatures;

                        accuracy = 0.9 - 0.4 * penalty - Math.random() * 0.1;

                    }



                    // Add some noise

                    accuracy += (Math.random() - 0.5) * 0.05;

                    accuracy = Math.max(0.5, Math.min(0.95, accuracy));



                    accuracies.push(accuracy);

                    featureCounts.push(features);

                }



                const trace = {

                    x: featureCounts,

                    y: accuracies,

                    mode: 'lines+markers',

                    type: 'scatter',

                    name: 'Classification Accuracy',

                    line: { color: 'blue', width: 3 },

                    marker: { size: 8 }

                };



                // Add optimal point

                const maxAccuracy = Math.max(...accuracies);

                const optimalIdx = accuracies.indexOf(maxAccuracy);

                const optimalFeatures = featureCounts[optimalIdx];



                const optimalTrace = {

                    x: [optimalFeatures],

                    y: [maxAccuracy],

                    mode: 'markers',

                    type: 'scatter',

                    name: 'Optimal Point',

                    marker: { color: 'red', size: 15, symbol: 'star' }

                };



                const layout = {

                    title: 'Classification Accuracy vs Number of Features',

                    xaxis: { title: 'Number of Features' },

                    yaxis: { title: 'Classification Accuracy', range: [0.5, 1.0] },

                    showlegend: true

                };



                Plotly.newPlot('featurePlot', [trace, optimalTrace], layout);



                // Update stats

                document.getElementById('optimalFeatures').textContent = optimalFeatures;

                document.getElementById('maxAccuracy').textContent = (maxAccuracy * 100).toFixed(1) + '%';

                document.getElementById('overfitting').textContent = optimalFeatures < maxFeatures ? 'Yes' : 'No';

            }



            // Run algorithm comparison

            function runComparison() {

            const noiseLevel = parseInt(document.getElementById('noiseLevel').value) / 100;

            const sampleSize = parseInt(document.getElementById('sampleSize').value);



            document.getElementById('noiseLevelDisplay').textContent = (noiseLevel * 100).toFixed(0) + '%';

            document.getElementById('sampleSizeDisplay').textContent = sampleSize;



            // Simulate performance comparison

            // NN performance decreases more with noise

            const nnAccuracy = Math.max(0.5, 0.9 - noiseLevel * 0.6 - Math.random() * 0.1);

            // Bayesian is more robust to noise but needs more data

            const bayesAccuracy = Math.max(0.5, 0.85 - noiseLevel * 0.3 + (sampleSize > 200 ? 0.1 : -0.1) - Math.random() * 0.05);



                // Generate comparison data

                const methods = ['Nearest Neighbor', 'Bayesian'];

                const accuracies = [nnAccuracy, bayesAccuracy];

                const colors = ['blue', 'red'];



                const trace = {

                    x: methods,

                    y: accuracies,

                    type: 'bar',

                    marker: { color: colors },

                    text: accuracies.map(acc => (acc * 100).toFixed(1) + '%'),

                    textposition: 'auto'

                };



                const layout = {

                    title: `Algorithm Comparison (Noise: ${(noiseLevel*100).toFixed(0)}%, Size: ${sampleSize})`,

                    yaxis: { title: 'Accuracy', range: [0, 1] }

                };



                Plotly.newPlot('comparisonPlot', [trace], layout);



                // Update comparison stats

                document.getElementById('nnCompAccuracy').textContent = (nnAccuracy * 100).toFixed(1) + '%';

                document.getElementById('bayesCompAccuracy').textContent = (bayesAccuracy * 100).toFixed(1) + '%';

                document.getElementById('winner').textContent = nnAccuracy > bayesAccuracy ? 'NN' : 'Bayes';

            }



            // Update general statistics

            function updateStats() {

                const totalTraining = classificationData.class1.x.length + classificationData.class2.x.length;

                document.getElementById('nnTrainingSize').textContent = totalTraining;

                document.getElementById('nnTestSize').textContent = testPoints.length;



                // Simulate accuracy calculation

                const accuracy = 0.85 + Math.random() * 0.1;

                document.getElementById('nnAccuracy').textContent = (accuracy * 100).toFixed(1) + '%';



                // Bayesian stats

                document.getElementById('bayesAccuracy').textContent = '89.3%';

                document.getElementById('bayesLogLikelihood').textContent = '-45.7';

            }



            // Toggle prior visualization

            function togglePriorVisualization() {

                // This would toggle the display of prior probability contours

                updateBayesian();

            }



            // Initialize everything when page loads

            window.onload = function() {

                generateClassificationData();

                generateClusterData();

                generateBayesianData();

                runFeatureExperiment();

                runComparison();

            };

        </script>

        ```



    </body>

</html>
